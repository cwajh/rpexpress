<{{
#include <cwajh.hh>
#include <string>
#include <vector>
#include <utility>
#include <regex>
#include <path_info.hh>
#include <user.hh>

#include "db/rpexpress.hh"
#include "db/rpexpress.odb.hh"

/*
	TODO(cwajh): Post handling logic
	Deletes are their OWN post, but all the other stuff still gets submitted.
	So if you typed some stuff, and then hit DELETE, it will only remove the deleted line, but return you to an editor form with your other changes intact.
	(via continuation, same as in an error case...)
	what about adds? not one at a time, clearly. +1/+5 buttons which reload and increment a GET parameter. again, continuing.
*/

ON_BAD_POST
	for(auto &field : fields) {
		if(has_prefix(field.first, L"trait_body_")) {
			env.post_outcome[field.first] = field.second;
		}
	}
	return env.path + L"?mode=edit";
END_BAD_POST

PERFORM_POST
	using namespace std;

	map<db::pkey_t, wstring> trait_bodies;
	// First, populate the continuation.
	for(auto &field : fields) {
		if(has_prefix(field.first, L"trait_body_")) {
			env.post_outcome[field.first] = field.second;
			try {
				trait_bodies[stoll(field.first.substr(11))] = field.second;
			} catch (invalid_argument e) {
				//TODO(cwajh): assert log
			} catch (out_of_range e) {
				//TODO(cwajh): assert log
			}
		}
	}
	wstring retry_path = env.path + L"?mode=edit";

	odb::core::transaction txn (env.p_odb->begin());
	P<db::mun> user = current_user(env.p_odb, env.session);
	if (!user) {
		// TODO(cwajh): can the login page do a continuation back into a post attempt?
		env.post_error = L"You don't seem to be signed in. Only signed in users can edit muse pages.";
		return retry_path;
	}
	db::muse muse;
	{
		typedef odb::query<db::muse> q_muse;
		auto result = env.p_odb->template query<db::muse>(q_muse::username == muse_for_path(env.path));
		if(result.empty()) {
			env.post_error = L"Tried to update a muse named ";
			env.post_error += muse_for_path(env.path) + L" but there's no such muse?";
			return L""; // TODO(cwajh): a proper "global error" page.
		}
		if(result.size() > 1) {
			//TODO(cwajh): assert log
		}
		muse = *(result.begin());
	}
	if (!muse.owner) {
		env.post_error = L"Muse with ID ";
		env.post_error += std::to_wstring(muse.muse_id) + L" has no owner?";
		return L"";
	}
	if (muse.owner->mun_id != user->mun_id) {
		env.post_error = L"The muse you were trying to edit, named ";
		env.post_error += muse_for_path(env.path) + L", doesn't seem to belong to you.";
		return retry_path;
	}
	// And now, update can finally begin.
	{
		typedef odb::query<db::trait> q_trait;
		auto result = env.p_odb->template query<db::trait>(
			(q_trait::character == q_trait::_val(muse))
			+ "ORDER BY" + q_trait::position
		);
		for(auto &trait : result) {
			auto post_it = trait_bodies.find(trait.trait_id);
			if (post_it != trait_bodies.end()) {
				trait.value.code = w2s(post_it->second);
				env.p_odb->update(trait);
				// At the end of the iteration, trait_bodies should be emptied.
				trait_bodies.erase(post_it);
			}
		}
		if(!trait_bodies.empty()) {
			env.post_error = L"Some traits were scheduled to be written but don't exist for this muse.<br/>";
			for(auto &unwritten_trait : trait_bodies)
			{
				env.post_error += std::to_wstring(unwritten_trait.first) + L";";
			}
			txn.rollback();
			return retry_path;
		}
	}
	txn.commit();
	return env.path; // back to the profile page from whence you came
END_PERFORM_POST

GEN_HEADERS
	using namespace std;
	struct {
		P<db::mun> user;
		wstring path;
		wstring path_with_query;
		bool found = false;
		db::muse muse;
		vector<db::trait> major_traits;
		vector<db::trait> minor_traits;
		db::artwork current_image;
		bool has_prev_img = false;
		bool has_next_img = false;
		// From query args.
		long image_index = 0;
		bool editor = false;
	} muse_info;

	odb::core::transaction txn (env.p_odb->begin());

	muse_info.user = current_user(env.p_odb, env.session);
	muse_info.path = env.path;
	muse_info.path_with_query = copal::user_box::path_with_query(env.path, env.get);

	{
		typedef odb::query<db::muse> q_muse;
		auto result = env.p_odb->template query<db::muse>(q_muse::username == muse_for_path(env.path));
		if(result.empty()) {
			headers["Status"] = "404 Not Found";
			muse_info.found = false;
			muse_info.muse.username = muse_for_path(env.path);
			return muse_info;
		}
		if(result.size() > 1) {
			//TODO(cwajh): assert log
		}
		muse_info.found = true;
		muse_info.muse = *(result.begin());
	}
	{
		typedef odb::query<db::trait> q_trait;
		auto result = env.p_odb->template query<db::trait>(
			(q_trait::character == q_trait::_val(muse_info.muse))
			+ "ORDER BY" + q_trait::position
		);
		for(auto &trait : result) {
			if(trait.category == db::major) {
				muse_info.major_traits.push_back(trait);
			} else if (trait.category == db::minor) {
				muse_info.minor_traits.push_back(trait);
			} else {
				//TODO(cwajh): assert log
			}
		}
	}

	muse_info.editor = false;
	auto mode_param = env.get.find(L"mode");
	if (mode_param != env.get.end()) {
		if(mode_param->second == L"edit" && muse_info.found
			&& muse_info.user && muse_info.muse.owner 
			&& muse_info.user->mun_id == muse_info.muse.owner->mun_id) {
			muse_info.editor = true;
		}
	}

	auto img_param = env.get.find(L"img");
	if (img_param == env.get.end()) {
		muse_info.image_index = 0;
	} else {
		muse_info.image_index = stol(img_param->second);
		if (muse_info.image_index < 0) {
			muse_info.image_index = 0;
		}
	}
	muse_info.has_prev_img = muse_info.image_index > 0;
	
	{
		typedef odb::query<db::artwork> q_art;
		auto result = env.p_odb->template query<db::artwork>(
			(q_art::subject == q_art::_val(muse_info.muse)) +
			"ORDER BY" + q_art::position);

		if(muse_info.image_index >= (signed long long)result.size()) {
			muse_info.image_index = result.size() - 1;
		}
		muse_info.has_next_img = muse_info.image_index+1 < (int)(result.size());

		int curr_idx = 0;
		for(db::artwork &artwork : result) {
			if(curr_idx == muse_info.image_index) {
				muse_info.current_image = artwork;
				break;
			}
			curr_idx++;
		}
	}

	txn.commit();
	return muse_info;
END_GEN_HEADERS

}}>
&&	if (!params.found) {
		<h1 No such character as &{{ params.muse.username }}&... >
&&		return;
&&	}
< html
	< head
		<link(rel='stylesheet' type='text/css' href='/static/theme.css') />
		<title &{{ params.muse.name }}&>
	>
	< body.doc_with_major_pane
		<@include user_box params@>
		<@include nav_bar params@>
		&& if (params.editor) {
			<form(method='post' action=&'{ params.path }'&) &{{ util.form_tokens(params.path) }}&
		&& }
		< div#major_pane

			< h1#muse_name &{{ params.muse.name }}&>
			< div#muse_portraits
				&/* Sorry this section is a mess. 
				  * All three img tags must have zero padding whitespace.
				  * Makes things awkward. */&

				<{{	std::wstring portrait_href(L"?img="); }}>
				<a(href='&{{ params.has_prev_img ? (portrait_href+std::to_wstring(params.image_index-1)) : L"" }}&') <img#prev_portrait_nav(&{{
					params.has_prev_img ? L"src='/static/prev_portrait_btn.png' class='prev_nav nav_enabled' alt='previous image'"
					                    : L"src='/static/prev_portrait_placeholder.png' class='prev_nav nav_disabled'"}}&)
				/>><img#muse_portrait(src='/static/&{{
					params.current_image.resource->hash + L"." + params.current_image.resource->extension
				}}&' title=&"{
					params.current_image.tooltip
				}"& alt=&"{
					params.current_image.fallback_text
				}"&)
				/><a(href='&{{ params.has_next_img ? (portrait_href+std::to_wstring(params.image_index+1)) : L"" }}&') <img#next_portrait_nav(&{{
					params.has_next_img ? L"src='/static/next_portrait_btn.png' class='next_nav nav_enabled' alt='next image'"
					                    : L"src='/static/next_portrait_placeholder.png' class='next_nav nav_disabled'"}}&) />>

			>

			<div#muse_profile &{{ params.muse.description }}& >
			<dl.stat_sheet#major_stats
				&&	for (auto trait : params.major_traits) {
					&& if (params.editor) {
						<div(style='float:right') Delete >
					&& }
					<dt.stat_name &{{ trait.name }}&> <dd.stat_value 
					&& if (params.editor) {
						<textarea(name='trait_body_&{{trait.trait_id}}&') &{{ trait.value.whtml_escaped_code() }}&>
					&& } else {
						&{{ trait.value.whtml() }}&
					&& }
					>
				&&	}
			>
		>
		< div#minor_pane
			< dl.stat_sheet#minor_stats
				<{{ for (auto trait : params.minor_traits) { }}>
					<dt.stat_name &{{ trait.name }}&> <dd.stat_value 
					&& if (params.editor) {
						<textarea(name='trait_body_&{{trait.trait_id}}&') &{{ trait.value.whtml_escaped_code() }}&>
					&& } else {
						&{{ trait.value.whtml() }}&
					&& }
					>
				<{{ } }}>
			>
			&& if (params.editor) {
			<input(type='submit' value='Save Changes') >
			&& }
		>
		&& if (params.editor) {
		>
		&& }
	>
>
